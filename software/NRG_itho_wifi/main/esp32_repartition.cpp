#include "esp32_repartition.h"

#define PARTITION_TABLE_SIZE 0x1000
#define PARTITION_TABLE_VALIDATE_SIZE 0x100
#define PARTITION_SPIFSS_START 0x3D0000
#define PARTITION_SPIFSS_SIZE_MIN_SPIFFS 0x30000
#define PARTITION_SPIFSS_SIZE_COREDUMP 0x20000

static const char ithowifi_parttable_min_spiffs[] = {
    0xaa, 0x50, 0x01, 0x02, 0x00, 0x90, 0x00, 0x00, 0x00, 0x50, 0x00, 0x00, 0x6e, 0x76, 0x73, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0xaa, 0x50, 0x01, 0x00, 0x00, 0xe0, 0x00, 0x00, 0x00, 0x20, 0x00, 0x00, 0x6f, 0x74, 0x61, 0x64, 0x61, 0x74, 0x61, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0xaa, 0x50, 0x00, 0x10, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x1e, 0x00, 0x61, 0x70, 0x70, 0x30, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0xaa, 0x50, 0x00, 0x11, 0x00, 0x00, 0x1f, 0x00, 0x00, 0x00, 0x1e, 0x00, 0x61, 0x70, 0x70, 0x31, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0xaa, 0x50, 0x01, 0x82, 0x00, 0x00, 0x3d, 0x00, 0x00, 0x00, 0x03, 0x00, 0x73, 0x70, 0x69, 0x66, 0x66, 0x73, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0xeb, 0xeb, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x3e, 0x74, 0xa3, 0x99, 0xf8, 0x85, 0x9c, 0x23, 0x45, 0x14, 0xde, 0x43, 0xee, 0xb7, 0x92, 0x4c,
    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff};

static const char ithowifi_parttable_coredump[] = {
    0xaa, 0x50, 0x01, 0x02, 0x00, 0x90, 0x00, 0x00, 0x00, 0x50, 0x00, 0x00, 0x6e, 0x76, 0x73, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0xaa, 0x50, 0x01, 0x00, 0x00, 0xe0, 0x00, 0x00, 0x00, 0x20, 0x00, 0x00, 0x6f, 0x74, 0x61, 0x64, 0x61, 0x74, 0x61, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0xaa, 0x50, 0x00, 0x10, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x1e, 0x00, 0x61, 0x70, 0x70, 0x30, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0xaa, 0x50, 0x00, 0x11, 0x00, 0x00, 0x1f, 0x00, 0x00, 0x00, 0x1e, 0x00, 0x61, 0x70, 0x70, 0x31, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0xaa, 0x50, 0x01, 0x82, 0x00, 0x00, 0x3d, 0x00, 0x00, 0x00, 0x02, 0x00, 0x73, 0x70, 0x69, 0x66, 0x66, 0x73, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0xaa, 0x50, 0x01, 0x03, 0x00, 0x00, 0x3f, 0x00, 0x00, 0x00, 0x01, 0x00, 0x63, 0x6f, 0x72, 0x65, 0x64, 0x75, 0x6d, 0x70, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0xeb, 0xeb, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xb4, 0x35, 0x13, 0xb1, 0x22, 0xc4, 0x18, 0x73, 0xa9, 0x01, 0x0b, 0x82, 0xec, 0x3a, 0x25, 0xbd,
    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff};

esp_vfs_littlefs_conf_t conf = {
    .base_path = "/littlefs",
    .partition_label = "spiffs",
    .format_if_mount_failed = true,
    .read_only = false,
    .dont_mount = false,
    .grow_on_mount = false};

bool validate_table(const char *input_table)
{
    char current_table[PARTITION_TABLE_VALIDATE_SIZE]{};

    disableCore0WDT();
    esp_err_t ret = esp_flash_read(esp_flash_default_chip, (void *)current_table, (uint32_t)CONFIG_PARTITION_TABLE_OFFSET, (uint32_t)PARTITION_TABLE_VALIDATE_SIZE);
    enableCore0WDT();
    if (ret != ESP_OK)
    {
        D_LOG("SYS: validate_table: esp_flash_read error");
        return false;
    }
    // Compare the contents of the input and flash_table
    for (int i = 0; i < PARTITION_TABLE_VALIDATE_SIZE; i++)
    {
        if (input_table[i] != current_table[i])
        {
            // The contents are different
            return false;
        }
    }
    // The contents are the same
    return true;
}

void write_partition_table(const char *new_table)
{
    esp_err_t ret = esp_flash_erase_region(esp_flash_default_chip, CONFIG_PARTITION_TABLE_OFFSET, PARTITION_TABLE_SIZE);
    if (ret == ESP_OK)
    {
        disableCore0WDT();
        if (esp_flash_write(esp_flash_default_chip, new_table, CONFIG_PARTITION_TABLE_OFFSET, PARTITION_TABLE_SIZE) != ESP_OK)
        {
            D_LOG("SYS: write_partition_table: data write failed");
        }
        enableCore0WDT();
    }
}

void erase_partition(uint32_t size)
{
    if (esp_flash_erase_region(esp_flash_default_chip, PARTITION_SPIFSS_START, size) != ESP_OK)
    {
        D_LOG("SYS: erase_partition: failed");
    }
}

void end_fs()
{
    ACTIVE_FS.end();
}

void check_partition_tables()
{
    const esp_partition_t *coredump_partition = esp_partition_find_first(ESP_PARTITION_TYPE_DATA, ESP_PARTITION_SUBTYPE_DATA_COREDUMP, "coredump");
    D_LOG("SYS: check coredump partition present: %s", coredump_partition != NULL ? "YES" : "NO");
    if (coredump_partition == NULL)
    {
        // coredump not present, repartition
        repartition_device("coredump");
    }
}

void backup_all_configs()
{
    D_LOG("SYS: Save all configs");

    NVS.setInt("usewificonfb", static_cast<uint8_t>(1));
    NVS.setInt("usesysconfb", static_cast<uint8_t>(1));
    NVS.setInt("uselogconfb", static_cast<uint8_t>(1));
    NVS.setInt("useremconfb", static_cast<uint8_t>(1));
    NVS.setInt("usevremconfb", static_cast<uint8_t>(1));

    saveWifiConfig("nvs");
    saveSystemConfig("nvs");
    saveLogConfig("nvs");
    saveRemotesConfig("nvs");
    saveVirtualRemotesConfig("nvs");
}

void load_all_configs()
{
    D_LOG("SYS: Load all configs before backup to NVS");

    // clear NVS to prevent any bogus readings
    nvs_flash_erase();
    nvs_flash_init();

    loadWifiConfig("flash");
    loadSystemConfig("flash");
    loadLogConfig("flash");
    loadRemotesConfig("flash");
    loadVirtualRemotesConfig("flash");
}

void revert_partitions_to_standard()
{

    const esp_partition_t *coredump_partition = esp_partition_find_first(ESP_PARTITION_TYPE_DATA, ESP_PARTITION_SUBTYPE_DATA_COREDUMP, "coredump");
    const esp_partition_t *spiffs = esp_partition_find_first(ESP_PARTITION_TYPE_DATA, ESP_PARTITION_SUBTYPE_DATA_SPIFFS, "spiffs");

    if (coredump_partition != NULL && spiffs->size == 0x20000)
    {
        end_fs();

        write_partition_table(ithowifi_parttable_min_spiffs);
        erase_partition(PARTITION_SPIFSS_SIZE_MIN_SPIFFS);

        D_LOG("SYS: Partition restored");
    }
}

void change_partitions_to_coredump()
{
    const esp_partition_t *coredump_partition = esp_partition_find_first(ESP_PARTITION_TYPE_DATA, ESP_PARTITION_SUBTYPE_DATA_COREDUMP, "coredump");
    const esp_partition_t *spiffs = esp_partition_find_first(ESP_PARTITION_TYPE_DATA, ESP_PARTITION_SUBTYPE_DATA_SPIFFS, "spiffs");

    if (coredump_partition == NULL && spiffs->size == 0x30000)
    {

        load_all_configs();

        NVS.begin();

        NVS.setInt("partupdated", static_cast<uint8_t>(1));

        backup_all_configs();

        NVS.close();

        end_fs();

        write_partition_table(ithowifi_parttable_coredump);
        erase_partition(PARTITION_SPIFSS_SIZE_COREDUMP);

        esp_restart();
    }
}

void repartition_device(const char *mode)
{
    const esp_partition_t *coredump_partition = esp_partition_find_first(ESP_PARTITION_TYPE_DATA, ESP_PARTITION_SUBTYPE_DATA_COREDUMP, "coredump");
    const esp_partition_t *spiffs = esp_partition_find_first(ESP_PARTITION_TYPE_DATA, ESP_PARTITION_SUBTYPE_DATA_SPIFFS, "spiffs");

    if (strcmp(mode, "legacy") == 0)
    {
        if (coredump_partition != NULL && spiffs != NULL)
        {
            D_LOG("SYS: Coredemp partition scheme detected, repartition to legacy table");
            revert_partitions_to_standard();
        }
        else
        {
            D_LOG("SYS: repartition_device() standard detect error");
        }
    }
    else if (strcmp(mode, "coredump") == 0)
    {
        if (coredump_partition == NULL && spiffs != NULL)
        {
            D_LOG("SYS: Standard partition scheme detected, repartition to coredump table");
            change_partitions_to_coredump();
        }
        else
        {
            D_LOG("SYS: repartition_device() coredump detect error");
        }
    }
    else
    {
        D_LOG("SYS: repartition_device() unknown mode");
    }
}

int current_partition_scheme()
{
    if (validate_table(ithowifi_parttable_min_spiffs))
    {
        return 0;
    }
    else if (validate_table(ithowifi_parttable_coredump))
    {
        return 1;
    }

    return -1;
}