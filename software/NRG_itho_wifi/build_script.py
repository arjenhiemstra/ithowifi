Import("env")
import gzip, os, glob, shutil, json, filecmp

from SCons.Script import (
    ARGUMENTS,
    COMMAND_LINE_TARGETS,
    AlwaysBuild,
    Builder,
    Default,
    DefaultEnvironment,
)

from sys import platform
from pathlib import Path

fwversion = "undefined"
release = "undefined"
hwref = "undefined"

my_flags = env.ParseFlags(env["BUILD_FLAGS"])
# print(my_flags)

defines = my_flags.get("CPPDEFINES")
for i in defines:
    if i[0] == "VERSION":
        fwversion = i[1]
        print("\nFirmware version: " + i[1])

PIOENV = env.subst("$PIOENV")
PROGNAME = env.subst("$PROGNAME")
firmware_bin = PROGNAME + ".bin"
firmware_elf = PROGNAME + ".elf"
PROJECT_DIR = env.subst("$PROJECT_DIR")
PROJECT_WORKSPACE_DIR = env.subst("$PROJECT_WORKSPACE_DIR")
PROJECT_BUILD_DIR = env.subst("$PROJECT_BUILD_DIR")
PROJECT_SRC_DIR = env.subst("$PROJECT_SRC_DIR")

print("PIOENV:" + PIOENV)
print("PROJECT_BUILD_DIR:" + PROJECT_BUILD_DIR)
print("PROJECT_DIR:" + PROJECT_DIR)
# print('PROGNAME:' + PROGNAME)
print("PROJECT_SRC_DIR:" + PROJECT_SRC_DIR)

if platform == "linux":
    print("Detected platform: Linux")
elif platform == "darwin":
    print("Detected platform: MacOS")
elif platform == "win32":
    print("Detected platform: Windows")
else:
    print("Detected platform: Failed!")
    exit()

WEBROOT_SRC_DIR = os.path.join(PROJECT_SRC_DIR, "webroot_source")
CONTROLS_JS_SRC_DIR = os.path.join(WEBROOT_SRC_DIR, "controls_js_sources")
WEBROOT_OUT_DIR = os.path.join(PROJECT_SRC_DIR, "webroot")
PROJECT_BIN_DIR = os.path.join(PROJECT_BUILD_DIR, PIOENV)
PROJECT_COMPILED_DIR = os.path.join(PROJECT_DIR, "..", "..", "compiled_firmware_files")
HW_BIN_DIR = ""

if PIOENV == "release":
    release = "release"
    hwrev = ""
    HW_BIN_DIR = "unified_hw2_noncve"
elif PIOENV == "beta":
    release = "beta"
    hwrev = ""
    HW_BIN_DIR = "unified_hw2_noncve"        
elif PIOENV == "debug":
    hwrev = "-debug"
    HW_BIN_DIR = "debug"
else:
    hwrev = "-dev"
    HW_BIN_DIR = "dev"


def export_version():
    outfile = open(os.path.join(PROJECT_SRC_DIR, "version.h"), "w", encoding="utf-8")
    outfile.write('#pragma once\n\n#define FWVERSION "' + fwversion + '"\n')


def concat_controls_js():
    print("### Combining javascript and HTML files into controls.js...")
    out_filename = os.path.join(WEBROOT_SRC_DIR, "controls.js")
    with open(out_filename, "w", encoding="utf-8") as outfile:
        outfile.write(
            "//This file is automatically generated - do not edit this file, edit the files in dir controls_js_sources instead and run the build\n"
        )

        print("\tAdding: " + os.path.join(CONTROLS_JS_SRC_DIR, "javascript.js"))
        with open(
            os.path.join(CONTROLS_JS_SRC_DIR, "javascript.js"), "r", encoding="utf-8"
        ) as js_infile:
            outfile.write(js_infile.read())

        for files in glob.glob(CONTROLS_JS_SRC_DIR + os.sep + "*.html"):
            print("\tAdding: " + files)
            with open(files, "r", encoding="utf-8") as infile:
                name, extension = os.path.splitext(os.path.basename(files))
                outfile.write("\nvar " + name + " = `\n")
                outfile.write(infile.read())
                outfile.write("\n`;\n")


def pop_first_line(file):
    with open(file, "r+", encoding="utf-8") as f:
        firstLine = f.readline()  # read the first line and throw it out
        data = f.read()  # read the rest
        outfile = open(
            os.path.join(WEBROOT_SRC_DIR, "controls_temp.js"), "w", encoding="utf-8"
        )
        outfile.write(data)


def make_c_header(inName, outName):
    if inName == "controls.js":
        inFileBytes = pop_first_line(os.path.join(WEBROOT_SRC_DIR, "controls.js"))
    else:
        infile = open(os.path.join(WEBROOT_SRC_DIR, inName), "rb")
        inFileBytes = infile.read()

    inFileGziped = gzip.compress(inFileBytes)
    print(
        "\twebroot_source"
        + inName
        + " non compressed ("
        + str(len(inFileBytes))
        + " bytes), gziped ("
        + str(len(inFileGziped))
        + " bytes) - writing to: webroot/"
        + outName
        + ".h"
    )
    outfile = open(os.path.join(WEBROOT_OUT_DIR, outName + ".h"), "w")

    outfile.write("#pragma once\n\nconst unsigned char " + outName + "[] = {\n\t\t")
    lineBreak = 40
    for b in inFileGziped:
        outfile.write(hex(b))
        outfile.write(", ")
        if lineBreak == 0:
            outfile.write("\n\t\t")
            lineBreak = 39
        lineBreak -= 1
    outfile.write(
        "};\n\nunsigned int " + outName + "_len = " + str(len(inFileGziped)) + ";\n"
    )

    infile.close()
    outfile.close()


def build_webui(*args, **kwargs):
    print("\n### Building webroot sources...\n")
    concat_controls_js()
    print("### Compressing webroot sources into gzipped header files...")
    pop_first_line(os.path.join(WEBROOT_SRC_DIR, "controls.js"))
    make_c_header("controls_temp.js", "controls_js_gz")
    os.remove(os.path.join(WEBROOT_SRC_DIR, "controls_temp.js"))
    make_c_header("index.html", "index_html_gz")
    make_c_header("edit.html", "edit_html_gz")
    make_c_header("pure-min.css", "pure_min_css_gz")
    make_c_header("jquery.min.js", "jquery_min_js_gz")
    make_c_header("favicon.png", "favicon_png_gz")
    print("\n### Webroot sources ready...\n")


def copy_firmware():
    if os.path.isfile(os.path.join(PROJECT_BIN_DIR, firmware_bin)):
        dest_fpath = os.path.join(
            PROJECT_COMPILED_DIR,
            HW_BIN_DIR,
            "nrgitho" + hwrev + "-v" + fwversion + ".bin",
        )
        print("Coping firmware file to: " + dest_fpath + "\n")
        os.makedirs(os.path.dirname(dest_fpath), exist_ok=True)
        shutil.copy(os.path.join(PROJECT_BIN_DIR, firmware_bin), dest_fpath)
        # check_sha1(name)
    else:
        print("Copy error! firmware file not found")
    if os.path.isfile(os.path.join(PROJECT_BIN_DIR, firmware_elf)):
        dest_fpath = os.path.join(
            PROJECT_COMPILED_DIR,
            HW_BIN_DIR,
            "elf",
            "nrgitho" + hwrev + "-v" + fwversion + ".elf",
        )
        print("Coping firmware elf file to: " + dest_fpath + "\n")
        os.makedirs(os.path.dirname(dest_fpath), exist_ok=True)
        shutil.copy(os.path.join(PROJECT_BIN_DIR, firmware_elf), dest_fpath)
        # check_sha1(name)
    else:
        print("Copy error! firmware elf file not found")

def copy_libs():
    source_path_libdeps = os.path.join(
        PROJECT_DIR,
        ".pio",
        "libdeps",
        PIOENV)
    source_path_lib = os.path.join(
        PROJECT_DIR,
        "lib")
    cwd = Path.cwd()
    goal_dir = cwd.parent
    target_path = os.path.join(
        goal_dir,
        "lib")
    print("source_path_libdeps:" + source_path_libdeps)
    print("source_path_lib:" + source_path_lib)
    print("target_path:" + target_path)
    try:
        sync_directories(source_path_libdeps, target_path)
        print("libdeps directory synchronized successfully.")
        sync_directories(source_path_lib, target_path)
        print("lib directory synchronized successfully.")
    except Exception as e:
        print(f"Error during directory synchronization: {e}")    


def is_hidden(path):
    """ Check if a file or directory is hidden """
    return os.path.basename(path).startswith('.')

def sync_directories(source, target):
    # Create sets of subdirectories in both source and target, excluding hidden ones
    source_dirs = set()
    for dirpath, dirnames, filenames in os.walk(source):
        if is_hidden(dirpath):
            continue  # Skip hidden directories
        dirnames[:] = [d for d in dirnames if not is_hidden(d)]  # Skip hidden subdirectories
        filenames[:] = [f for f in filenames if not is_hidden(f)]  # Skip hidden files
        source_dirs.add(os.path.relpath(dirpath, source))

    target_dirs = set(os.path.relpath(dirpath, target)
                      for dirpath, dirnames, filenames in os.walk(target)
                      if not is_hidden(dirpath))

    # Identify subdirectories present in source but not in target
    source_only_dirs = source_dirs - target_dirs

    # Delete and then copy these subdirectories to the target
    for subdir in source_only_dirs:
        abs_subdir_source = os.path.join(source, subdir)
        abs_subdir_target = os.path.join(target, subdir)

        if os.path.exists(abs_subdir_target):
            shutil.rmtree(abs_subdir_target)
        shutil.copytree(abs_subdir_source, abs_subdir_target, ignore=shutil.ignore_patterns('.*'))

def update_releaseinfo():
    if release == "beta" or release == "stable":
        print("\n### Updating releaseinfo for the " + release + " release\n")

        latest_fw_key = "latest_fw" if release == "stable" else "latest_beta_fw"
        latest_link_key = "link" if release == "stable" else "link_beta"
        latest_fw_file = "nrgitho" + hwrev + "-v" + fwversion + ".bin"

        releasefile = os.path.join(PROJECT_COMPILED_DIR, "firmware.json")
        with open(releasefile) as f:
            data = json.load(f)

        data["hw_rev"]["2"][latest_link_key] = (
            "https://github.com/arjenhiemstra/ithowifi/raw/master/compiled_firmware_files/"+ HW_BIN_DIR +"/"
            + latest_fw_file
        )
        data["hw_rev"]["2"][latest_fw_key] = fwversion

        data["hw_rev"]["NON-CVE 1"][latest_link_key] = (
            "https://github.com/arjenhiemstra/ithowifi/raw/master/compiled_firmware_files/"+ HW_BIN_DIR +"/"
            + latest_fw_file
        )
        data["hw_rev"]["NON-CVE 1"][latest_fw_key] = fwversion
        json_object = json.dumps(data, indent=4)

        with open(
            os.path.join(PROJECT_COMPILED_DIR, "firmware.json"), "w", encoding="utf-8"
        ) as outfile:
            outfile.write(json_object)


def build_prep(*args, **kwargs):
    print("\n### running build preparation commands...\n")
    export_version()
    build_webui(*args, **kwargs)


def build_after(*args, **kwargs):
    print("\n### running post build commands...\n")
    copy_firmware()
    if(PIOENV == "beta" or PIOENV == "release"):
        copy_libs()
    update_releaseinfo()


env.Execute(build_prep)

env.AddPostAction("buildprog", build_after)
